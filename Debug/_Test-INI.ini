# Informations the cool GUI will show
[ToolInfo]
# Title=<string>                    The title FEMDAQ will show within its title-bar
# Operator=<string>                 The name of the operator is printed to the status-bar
# Description=<string>              The description is printed to the status-bar
# Comment=<string>                  This is just for you
Title=FEMDAQ
Operator=haum
Description=Test for new feature (sub-interval measurements)
Comment=

# Other tool-settings
[ToolSettings]
# SaveResultsGrouped=<bool>         Should each save grouped into a newly created folder (named after a timestamp)
SaveResultsGrouped=true

# Information for a auto-load sweepfile
[SweepInfo]
# StartupSweep=<string>             Can be an absolute or relative (to FEMDAQ.exe) path to a sweepfile which is the automatically loaded after the ini
StartupSweep=

# Timing-Informations
[Timing]
# Initial=<uint>                    Cycle-duration for the first/initial step when starting a measurement in [ms]
# Iterative=<uint>                  Cycle-duration for all other steps expect the first one in [ms]
# Comment=<string>                  This is just for you
Initial=3000
Iterative=3000
Comment=





# FEAR16v2 provides as drawnOver: DevXY|Ch<int>|<Type>
#  where <Type> = CC (CurrentControl), CF (CurrentFlow), UD (FET VoltageDrop)
#  ATTENTION! CF and UD of the corresponding channel is not measured, the drawnOver-Value will be 0!
[Dev100|FEAR16v2]
#---------------- General settings ----------------
# ComPort=COM<uint>                 COM-Port of the device
# Baudrate=<uint>                   Communication speed of the device in [baud]; !!! DO NOT TOUCH !!!
# Comment=<string>                  This is just for you
ComPort=COM4
Baudrate=115200
Comment=
#---------------- General ADC settings ----------------
# AdcNMean=<uint>                   The last <uint> measurement points gets meaned together.
# AdcMDelta=<uint>                  Delta-time bewtween ADC-Measurements in [ms]. Combined with AdcNMean you get the meaning-time, e.g.:     4 Points (NMean) * 25 ms (MDelta) = 100ms
# RequestDelay=<int>                Delays the actual request of data by this time given in [ms]. Only active if <int> > 0! (normally: RequestDelay_ms = AdcNMean * AdcMDelta)
# nSubMeasurements=<uint>           Takes n Measurment points per global interval (see [Timing]).
#                                    <uint> = 0 or 1:   One datapoint
#                                    <uint> >= 2:       Multiple datapoints
#                                    !!! NOTE !!!
#                                     This feature works properly for devices of a multi-device-communication.
#                                     GPIB will therefore only work properly with one GPIB-device! (GPIB-Devices
#                                     measured in series by one single thread due to incapability of multi-device-communication)
# deltatimeSubmeasurements=<uint>   The interval between submeasurements [ms]
#                                    !!! NOTE !!!       nSubMeasurements * deltatimeSubmeasurements <= GlobalInterval      (see [Timing])
AdcNMean=10
AdcMDelta=10
RequestDelay=110
nSubMeasurements=4
deltatimeSubmeasurements=250
#---------------- CurrentControl ----------------
# Ch<uint>CC=<int>							Channel 0-15 is connected to headercolumn: CC<int>
#Ch0CC=0 Not using the DAC in this test
#---------------- CurrentFlow ----------------
# Ch<uint>CF=<int>							Channel 0-15 CurrentFlow measurement: <int> = -1 (disabled), 0 (@CycleEnd), 1 (CycleStart)
#   Hint: Unlisted Channels (no Ch<int>CF=<int> line) also disables the channel!
# Ch<uint>CFChartIdentifier=Chart<int>		Channel 0-15 plots data to Chart<int> (can have multiple entries separated by ",")
# Ch<uint>CFChartDrawnOver=<drawnOverSpec>	Channel 0-15 plots over: <drawnOver> = Time or check device-blocks for supported specifier; MUST have same or more entries as ChartIdentifier
# Ch<uint>CFChartColor=<color>				Channel 0-15 plots in color: <color> = check _ColorTable; MUST have same or more entries as ChartIdentifier
# Ch<uint>CFCustomName=<string>			Channel 0-15 contains <string> in it's saved data-filename, otherwise the file gets a standard-filename
Ch0CF=0
Ch0CFChartIdentifier=Chart1, Chart2
Ch0CFChartDrawnOver=Time, Dev1000
Ch0CFChartColor=red, red
Ch0CFCustomName=
Ch1CF=0
Ch1CFChartIdentifier=Chart1, Chart2
Ch1CFChartDrawnOver=Time, Dev1000
Ch1CFChartColor=green, green
Ch1CFCustomName=
Ch2CF=0
Ch2CFChartIdentifier=Chart1, Chart2
Ch2CFChartDrawnOver=Time, Dev1000
Ch2CFChartColor=blue, blue
Ch2CFCustomName=
Ch3CF=0
Ch3CFChartIdentifier=Chart1, Chart2
Ch3CFChartDrawnOver=Time, Dev1000
Ch3CFChartColor=orange, orange
Ch3CFCustomName=
#---------------- FET VoltageDrop ----------------
# Ch<uint>UD=<int>							Channel 0-15 FET VoltageDrop measurement: <int> = -1 (disabled), 0 (@CycleEnd), 1 (CycleStart)
#   Hint: Unlisted Channels (no Ch<int>CF=<int> line) also disables the channel!
# Ch<uint>UDChartIdentifier=Chart<int>		Channel 0-15 plots data to Chart<int> (can have multiple entries separated by ",")
# Ch<uint>UDChartDrawnOver=<drawnOverSpec>	Channel 0-15 plots over: <drawnOver> = Time or check device-blocks for supported specifier; MUST have same or more entries as ChartIdentifier
# Ch<uint>UDChartColor=<color>				Channel 0-15 plots in color: <color> = check _ColorTable; MUST have same or more entries as ChartIdentifier
# Ch<uint>UDCustomName=<string>			Channel 0-15 contains <string> in it's saved data-filename, otherwise the file gets a standard-filename
Ch0UD=0
Ch0UDChartIdentifier=Chart3, Chart4
Ch0UDChartDrawnOver=Time, Dev1000
Ch0UDChartColor=red, red
Ch0UDCustomName=
Ch1UD=0
Ch1UDChartIdentifier=Chart3, Chart4
Ch1UDChartDrawnOver=Time, Dev1000
Ch1UDChartColor=green, green
Ch1UDCustomName=
Ch2UD=0
Ch2UDChartIdentifier=Chart3, Chart4
Ch2UDChartDrawnOver=Time, Dev1000
Ch2UDChartColor=blue, blue
Ch2UDCustomName=
Ch3UD=0
Ch3UDChartIdentifier=Chart3, Chart4
Ch3UDChartDrawnOver=Time, Dev1000
Ch3UDChartColor=orange, orange
Ch3UDCustomName=


## KE6485 provides as drawnOver: DevXY
##  returns always 0 (has no source)
#[Dev14|KE6485]
##---------------- General settings ----------------
## GpibAddr=<uint>, <uint>, <uint>   GPIB-Adress:        GPIB-Adapter, Primary-Adress, Secondary-Adress
##                                    Possible adresses: 0,            14,             0
## CustomName=<string>               Saved outputfile contains <string> in it's filename, otherwise the file gets a standard-filename
## Comment=<string>                  This is just for you
#GpibAddr=0, 14, 0
#CustomName=
#Comment=
##---------------- Measurement ----------------
## MeasureInstantly=<int>            Measurement @ <int> = -1 (disabled), 0 (@CycleEnd), 1 (CycleStart)
## nSubMeasurements=<uint>           Takes n Measurment points per global interval (see [Timing]).
##                                    <uint> = 0 or 1:   One datapoint
##                                    <uint> >= 2:       Multiple datapoints
##                                    !!! NOTE !!!
##                                     This feature works properly for devices of a multi-device-communication.
##                                     GPIB will therefore only work properly with one GPIB-device! (GPIB-Devices
##                                     measured in series by one single thread due to incapability of multi-device-communication)
## deltatimeSubmeasurements=<uint>   The interval between submeasurements [ms]
##                                    !!! NOTE !!!       nSubMeasurements * deltatimeSubmeasurements <= GlobalInterval      (see [Timing])
## Range=<double>                    Measurment-Range: <double> = 20e-12 ... 20e-3 [A] (in decades!); Not sure about min-value
## Nplc=<double>                     Integrationtime in NetPowerLineCycles: <double> = 0 ... 20 (* 1/50Hz) [ms]; not sure about the double and min/max value
## ZeroCheck=<bool>                  Connect measurementchannel to reference resistor: <bool> = true/false
## AutoZero=<bool>                   Offsetcorrection: <bool> = true/false;
#MeasureInstantly=0
#nSubMeasurements=1
#deltatimeSubmeasurements=2000
#Range=20e-3
#Nplc=5
#ZeroCheck=false
#AutoZero=true
##---------------- DataPlot ----------------
## ChartIdentifier=Chart<int>        Plots data to Chart<int> (can have multiple entries separated by ",")
## ChartDrawnOver=<drawnOverSpecs>   Plots over: <drawnOver> = Time or check device-blocks for supported specifier; MUST have same or more entries as ChartIdentifier
## ChartColor=<color>                Plots in color: <color> = check _ColorTable; MUST have same or more entries as ChartIdentifier
##                                                   Good visible is: black, blue, brown, Green, Orange, Plum, Red, Purple
#ChartIdentifier=Chart1, Chart2
#ChartDrawnOver=Time, Dev1000
#ChartColor=orange, orange





# DmySU provides as drawnOver: DevXY
#  where the result is always its last SourceNode-value from the connected sweep-file
[Dev1000|DmySU]
#---------------- General settings ----------------
# CustomName=<string>               Saved outputfile contains <string> in it's filename, otherwise the file gets a standard-filename
# Comment=<string>                  This is just for you
CustomName=DSU
Comment=
#---------------- SourceControl ----------------
# SourceNode=<int>                  Source is connected to headercolumn "U<int>"; -1 disables the source
SourceNode=1000




# Chart-Blocks
[Chart1|CF vs t]
# XAxisTitle=<string>                             Title for the x-axis
# YAxisTitle=<string>                             Title for the y-axis
# XAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
# YAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
#                                                 First  <fix>: @ will fix the lower boundary given by the first  <double>
#                                                 Second <fix>: @ will fix the upper boundary given by the second <double>
#                                                 Fixing only one boundary is not possible currently! You have to fix both!
# XAxisLogBase=<uint>                             <uint> is the log-base value for the x-axis (e.g. 0 and 1 is linear)
# YAxisLogBase=<uint>                             <uint> is the log-base value for the y-axis (e.g. 0 and 1 is linear)
# ShowLegend=<bool>                               Should the chart legend plotted
XAxisTitle=Time [s]
YAxisTitle=Current [I]
XAxisBoundaries=0|0
YAxisBoundaries=0|0
XAxisLogBase=0
YAxisLogBase=1
ShowLegend=1

[Chart2|CF vs U]
# XAxisTitle=<string>                             Title for the x-axis
# YAxisTitle=<string>                             Title for the y-axis
# XAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
# YAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
#                                                 First  <fix>: @ will fix the lower boundary given by the first  <double>
#                                                 Second <fix>: @ will fix the upper boundary given by the second <double>
#                                                 Fixing only one boundary is not possible currently! You have to fix both!
# XAxisLogBase=<uint>                             <uint> is the log-base value for the x-axis (e.g. 0 and 1 is linear)
# YAxisLogBase=<uint>                             <uint> is the log-base value for the y-axis (e.g. 0 and 1 is linear)
# ShowLegend=<bool>                               Should the chart legend plotted
XAxisTitle=Voltage [V]
YAxisTitle=Current [I]
XAxisBoundaries=0|0
YAxisBoundaries=0|0
XAxisLogBase=0
YAxisLogBase=1
ShowLegend=1



[Chart3|UDrp vs t]
# XAxisTitle=<string>                             Title for the x-axis
# YAxisTitle=<string>                             Title for the y-axis
# XAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
# YAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
#                                                 First  <fix>: @ will fix the lower boundary given by the first  <double>
#                                                 Second <fix>: @ will fix the upper boundary given by the second <double>
#                                                 Fixing only one boundary is not possible currently! You have to fix both!
# XAxisLogBase=<uint>                             <uint> is the log-base value for the x-axis (e.g. 0 and 1 is linear)
# YAxisLogBase=<uint>                             <uint> is the log-base value for the y-axis (e.g. 0 and 1 is linear)
# ShowLegend=<bool>                               Should the chart legend plotted
XAxisTitle=Voltage [V]
YAxisTitle=Current [I]
XAxisBoundaries=0|0
YAxisBoundaries=0|0
XAxisLogBase=0
YAxisLogBase=1
ShowLegend=1


[Chart4|UDrp vs U]
# XAxisTitle=<string>                             Title for the x-axis
# YAxisTitle=<string>                             Title for the y-axis
# XAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
# YAxisBoundaries=<fix><double>|<fix><double>     BETA-Feature
#                                                 First  <fix>: @ will fix the lower boundary given by the first  <double>
#                                                 Second <fix>: @ will fix the upper boundary given by the second <double>
#                                                 Fixing only one boundary is not possible currently! You have to fix both!
# XAxisLogBase=<uint>                             <uint> is the log-base value for the x-axis (e.g. 0 and 1 is linear)
# YAxisLogBase=<uint>                             <uint> is the log-base value for the y-axis (e.g. 0 and 1 is linear)
# ShowLegend=<bool>                               Should the chart legend plotted
XAxisTitle=Voltage [V]
YAxisTitle=Current [I]
XAxisBoundaries=0|0
YAxisBoundaries=0|0
XAxisLogBase=0
YAxisLogBase=1
ShowLegend=1



